#' @param bsigma2 Rate parameter for the prior Gamma distribution of the variances `sigma2_k`.
#' @param alpha_dirichlet Vector of parameters for the Dirichlet prior on the component weights.
#' @param nsim Number of MCMC iterations for Gibbs sampling.
#' @param nburn Number of burn-in iterations to discard before computing results.
#'
#' @return A list containing:
#' \item{samples}{MCMC samples of the parameters from the posterior distribution.}
#' \item{density}{A matrix of density estimates for each grid point.}
#' \item{grid}{Grid points over which the density was computed.}
gmm <- function(y, grid, K, amu, b2mu, asigma2, bsigma2, alpha_dirichlet, nsim, nburn) {
# JAGS model specification
gmm_model <- "
model {
for (i in 1:n) {
# Latent variable indicating the component assignment
z[i] ~ dcat(w[])
# Observation modeled as a normal distribution
y[i] ~ dnorm(mu[z[i]], tau[z[i]])
}
for (k in 1:K) {
# Priors for the means and precisions of the components
#note in jags, dnorm(mu, tau)
mu[k] ~ dnorm(amu, b2mu)
tau[k]  ~ dgamma(asigma2, bsigma2)
}
# Dirichlet prior for the weights
w[1:K] ~ ddirch(alpha_dirichlet[])
}
"
# Data for the JAGS model
data_gmm <- list(y = y, n = length(y), K = K, amu = amu, b2mu = b2mu,
asigma2 = asigma2, bsigma2 = bsigma2, alpha_dirichlet = alpha_dirichlet)
# Initial values for MCMC
inits_gmm <- function() {
list(
mu = seq(-5,5, length.out = K),
tau = rep(1, K),
z = sample(1:K, length(y), replace = TRUE)
)
}
# Parameters to monitor (mu, tau, and w)
params_gmm <- c("mu", "tau", "w")
# Running the model
jagsModel_gmm <- jags.model(textConnection(gmm_model), data = data_gmm, inits = inits_gmm,
n.chains = 1, n.adapt = 1000)
# Burn-in and sampling
update(jagsModel_gmm, nburn)
samples_gmm <- coda.samples(jagsModel_gmm, variable.names = params_gmm, n.iter = nsim)
# Extract MCMC samples as a matrix for further analysis
samples_matrix_gmm <- as.matrix(samples_gmm)
# Extract posterior samples for weights, means, and variances
w_samples_gmm <- samples_matrix_gmm[, grep("w", colnames(samples_matrix_gmm))]
mu_samples_gmm <- samples_matrix_gmm[, grep("mu", colnames(samples_matrix_gmm))]
tau_samples_gmm <- samples_matrix_gmm[, grep("tau", colnames(samples_matrix_gmm))]
# sigma2_samples_gmm <- 1 / tau_samples_gmm
# Compute densities over the grid points
density <- matrix(0, nrow = nrow(w_samples_gmm), ncol = length(grid))
for (g in 1:length(grid)) {
for (k in 1:K) {
density[, g] <- density[, g] + w_samples_gmm[, k] * dnorm(grid[g],
mean = mu_samples_gmm[, k],
sd = sqrt(1/tau_samples_gmm[, k]))
}
}
"
hey
"
return(list(samples = samples_gmm, density = density, grid = grid))
}
require(mixtools)
source("code/Bayes_mix_normal.R")
set.seed(123)
n <- 500
ymix_norm <- rnormmix(n = n, lambda = c(0.6, rep(0.05, 8), 0.1),
mu = seq(1, 20, by = 2), sigma = rep(1, 10))
y <- ymix_norm
plot(ecdf(y))
grid <- seq(min(y) - 1, max(y) + 1, len = 200)
ngrid <- length(grid)
# Components number (K = 20, 40, 50)
K <- 20
# Alpha (0.1, 0.5, 0.7, 1)
alpha = 1
fit_gmm <- gmm(y = y, grid = grid,  K = K, amu = 5, b2mu = 0.01, asigma2 = 1,
bsigma2 = 1, alpha_dirichlet = rep(alpha, K), nsim = 5000, nburn = 1000)
gmm_samples <- fit_gmm$samples
ess_val_gmm <- effectiveSize(gmm_samples)
# Effective sample size
ess_values_norm <- apply(gmm_dens, 2, coda::effectiveSize)
gmm_dens <- fit_gmm$density
# Effective sample size
ess_values_norm <- apply(gmm_dens, 2, coda::effectiveSize)
# Effective sample size
ess_values_norm <- apply(gmm_dens, 2, coda::effectiveSize)
plot(grid, ess_values_sqrt_norm, type = "l", col = "black", lwd = 2,
xlab = "Grid Points", ylab = "Effective Sample Size (ESS)",
main = "ESS across Grid Points for GMM (alpha = 1) on Data ")
plot(grid, ess_values_norm, type = "l", col = "black", lwd = 2,
xlab = "Grid Points", ylab = "Effective Sample Size (ESS)",
main = "ESS across Grid Points for GMM (alpha = 1) on Data ")
points(grid, ess_values_sqrt_norm, pch = 16, col = "black")
points(grid, ess_values_norm, pch = 16, col = "black")
# Estimated density
dens3m <- apply(gmm_dens, 2, mean)
dens3l <- apply(gmm_dens, 2, quantile, prob = 0.025)
dens3h <- apply(gmm_dens, 2, quantile, prob = 0.975)
dfhist <- data.frame(y = y)
dfdens3 <- data.frame(dm = dens3m, dl = dens3l, dh = dens3h,
seqgrid = grid)
ggplot(dfdens3, aes(x = seqgrid, y = dm)) + geom_line(size = 1, colour = "blue") +
geom_ribbon(data = dfdens3, aes(x = seqgrid, ymin = dl, ymax = dh),
alpha = 0.3, fill = "dodgerblue1") + xlab("y") + ylab("Density") + geom_histogram(data = dfhist, aes(x = y,
y = after_stat(density)), alpha = 0.2, bins = 40, inherit.aes = FALSE,
fill = "gray", colour = "black")+ theme_bw(base_size = 15) + theme(plot.title = element_text(hjust = 0.5, face="bold"),panel.grid.major = element_blank(),
panel.grid.minor = element_blank(), text = element_text(size = 15))
set.seed(123)
random_index <- sample(1:ncol(gmm_dens), 1)
plot(dp_gmm_dens[, random_index], type = "l",
xlab = "Iteration", ylab = "Density")
plot(gmm_dens[, random_index], type = "l",
xlab = "Iteration", ylab = "Density")
# Weight components plot
fit_gmm_samples <- as.matrix(fit_gmm$samples)
w_samples_20 <- fit_gmm_samples[, grep("^w\\[", colnames(fit_gmm_samples))]
set.seed(2333)  # For reproducibility
random_sample <- sample(1:nrow(w_samples_20), 1)  # Select a random row index
weights <- w_samples_20[random_sample, ]  # Extract weights for that sample
# Using Base R
plot(1:20, weights, type = "o", col = "blue", pch = 16, lwd = 2,
main = paste(""),
xlab = "Component", ylab = "Weight")
source("code/Bayes_mix_poisson.R")
set.seed(123)
n <- 500
y_van <- numeric(n)
u <- runif(n)
for(i in 1:n){
if(u[i] < 0.4) {y_van[i] <- rpois(1, lambda = 2)}
else
if(u[i] < 0.8) {y_van[i] <- rpois(1, lambda = 6)}
else {y_van[i] <- rpois(1, lambda = 10)}
}
mean(y_van) #5.032
var(y_van) #14.35569
K = 20
alpha = 1
#grid <- seq(min(obs_data) - 1, max(obs_data) + 1, length = 200)
grid <- seq(min(obs_data) - 1, max(obs_data) + 1, by = 1)
obs_data <- y_van
res_pois <- pmm(y = obs_data, grid = grid, K = K, alpha = 1, beta = 1, alpha_dir = rep(alpha,K))
alpha_p = 1
grid <- seq(min(obs_data) - 1, max(obs_data) + 1, by = 1)
res_pois <- pmm(y = obs_data, grid = grid, K = K, alpha = 1, beta = 1, alpha_dir = rep(alpha_p,K))
density_pmm <- res_pois$density
# ESS
ess_values <- apply(density_pmm, 2, coda::effectiveSize)
plot(grid, ess_values, type = "l", col = "black", lwd = 2,
xlab = "Grid Points", ylab = "Effective Sample Size (ESS)")
points(grid, ess_values, pch = 16, col = "black")
set.seed(123)
random_index <- sample(1:ncol(density_pmm), 1)
# Plot the trace of the density at this selected grid point
plot(density_pmm[, random_index], type = "l",
main = paste("PMM Trace Plot on Overdispersed Data (K = 20)"),
xlab = "Iteration", ylab = "Density")
# Plot the trace of the density at this selected grid point
plot(density_pmm[, random_index], type = "l",
xlab = "Iteration", ylab = "Density")
# Estimated density
mean_density <- apply(density_pmm, 2, mean)
lower_density <- apply(density_pmm, 2, quantile, prob = 0.025)
upper_density <- apply(density_pmm, 2, quantile, prob = 0.975)
density_df <- data.frame(
grid = grid,
mean_density = mean_density,
lower_density = lower_density,
upper_density = upper_density
)
#plot density and dataset of poisson mix model
ggplot(density_df, aes(x = grid, y = mean_density)) +
geom_line(size = 1) +  #original density curve
stat_smooth(aes(y = mean_density), method = "loess", span = 0.1, color = "blue", se = FALSE) +  #smoothed curve
geom_ribbon(aes(ymin = lower_density, ymax = upper_density), alpha = 0.3, fill = "dodgerblue1") +
geom_histogram(data = dfhist_jags, aes(x = obs_data, y = after_stat(density)),
alpha = 0.2, bins = 40, inherit.aes = FALSE, fill = "gray", colour = "black") +
xlab("y") + ylab("Density") + ggtitle(sprintf("K= %d", K)) +
theme(text = element_text(size = 20), plot.title = element_text(hjust = 0.5)) +
ylim(0, 0.25)
#for under dispersed and over - can change graph scale
# Adjust the y-axis limit and other graphical parameters to make the plot more readable
y_max <- max(c(mean_density, obs_density)) * 1  # Set the max y limit slightly above the max density
# Overlay the observed data as a dotted vertical line density plot, shifted by 'offset'
offset <- 0.1  # Small offset for side-by-side display
obs_density <- table(factor(obs_data, levels = grid)) / length(obs_data)  # Calculate density for observed data
points(grid + offset, obs_density, type = "h", lwd = 2, col = "black", lty = 3)  # Use type "h" with dotted line
# Add a legend to indicate each element
legend("topright", legend = c("Mean Density", "95% CI", "Observed Data"),
col = c("gray", rgb(0, 0, 1, 0.2), "black"), lty = c(1, NA, 3),
lwd = c(2, NA, 2), fill = c(NA, rgb(30/255, 144/255, 255/255, 0.3), NA), border = NA)
dfhist_jags <- data.frame(y = obs_data)
par(mfrow=c(1, 2))
plot(grid, mean_density, type = "h", lwd = 2, color = "blue", xlab = "y", ylab = "Density",
main = sprintf("K = %d", K))
#plot density and dataset of poisson mix model
ggplot(density_df, aes(x = grid, y = mean_density)) +
geom_line(size = 1) +  #original density curve
stat_smooth(aes(y = mean_density), method = "loess", span = 0.1, color = "blue", se = FALSE) +  #smoothed curve
geom_ribbon(aes(ymin = lower_density, ymax = upper_density), alpha = 0.3, fill = "dodgerblue1") +
geom_histogram(data = dfhist_jags, aes(x = obs_data, y = after_stat(density)),
alpha = 0.2, bins = 40, inherit.aes = FALSE, fill = "gray", colour = "black") +
xlab("y") + ylab("Density") + ggtitle(sprintf("K= %d", K)) +
theme(text = element_text(size = 20), plot.title = element_text(hjust = 0.5)) +
ylim(0, 0.25)
# Plot the mean density using type = "h" for vertical lines (no offset)
plot(grid, mean_density, type = "h", lwd = 2, col = "gray",
xlab = "y", ylab = "Density", ylim = c(0, y_max),
main = paste("Poisson Mixture Model Density for K =", K))
# Add shaded area for the 95% credible interval
polygon(c(grid, rev(grid)),
c(lower_density, rev(upper_density)),
col = rgb(30/255, 144/255, 255/255, 0.3), border = NA)
#for under dispersed and over - can change graph scale
# Adjust the y-axis limit and other graphical parameters to make the plot more readable
y_max <- max(c(mean_density, obs_density)) * 1  # Set the max y limit slightly above the max density
# Plot the mean density using type = "h" for vertical lines (no offset)
plot(grid, mean_density, type = "h", lwd = 2, col = "gray",
xlab = "y", ylab = "Density", ylim = c(0, y_max),
main = paste("Poisson Mixture Model Density for K =", K))
# Add shaded area for the 95% credible interval
polygon(c(grid, rev(grid)),
c(lower_density, rev(upper_density)),
col = rgb(30/255, 144/255, 255/255, 0.3), border = NA)
# Overlay the observed data as a dotted vertical line density plot, shifted by 'offset'
offset <- 0.1  # Small offset for side-by-side display
obs_density <- table(factor(obs_data, levels = grid)) / length(obs_data)  # Calculate density for observed data
points(grid + offset, obs_density, type = "h", lwd = 2, col = "black", lty = 3)  # Use type "h" with dotted line
# Add a legend to indicate each element
legend("topright", legend = c("Mean Density", "95% CI", "Observed Data"),
col = c("gray", rgb(0, 0, 1, 0.2), "black"), lty = c(1, NA, 3),
lwd = c(2, NA, 2), fill = c(NA, rgb(30/255, 144/255, 255/255, 0.3), NA), border = NA)
dfhist_jags <- data.frame(y = obs_data)
par(mfrow=c(1, 2))
plot(grid, mean_density, type = "h", lwd = 2, color = "blue", xlab = "y", ylab = "Density",
main = sprintf("K = %d", K))
plot(grid, mean_density, type = "h", lwd = 2, col = "gray",
xlab = "y", ylab = "Density", ylim = c(0, y_max),
main = paste("Poisson Mixture Model Density for K =", K))
# Add shaded area for the 95% credible interval
polygon(c(grid, rev(grid)),
c(lower_density, rev(upper_density)),
col = rgb(30/255, 144/255, 255/255, 0.3), border = NA)
plot(grid, mean_density, type = "h", lwd = 2, col = "gray",
xlab = "y", ylab = "Density", ylim = c(0, y_max),
main = paste("Poisson Mixture Model Density for K =", K))
# Add shaded area for the 95% credible interval
polygon(c(grid, rev(grid)),
c(lower_density, rev(upper_density)),
col = rgb(30/255, 144/255, 255/255, 0.3), border = NA)
# Overlay the observed data as a dotted vertical line density plot, shifted by 'offset'
offset <- 0.1  # Small offset for side-by-side display
obs_density <- table(factor(obs_data, levels = grid)) / length(obs_data)  # Calculate density for observed data
points(grid + offset, obs_density, type = "h", lwd = 2, col = "black", lty = 3)  # Use type "h" with dotted line
# Add a legend to indicate each element
legend("topright", legend = c("Mean Density", "95% CI", "Observed Data"),
col = c("gray", rgb(0, 0, 1, 0.2), "black"), lty = c(1, NA, 3),
lwd = c(2, NA, 2), fill = c(NA, rgb(30/255, 144/255, 255/255, 0.3), NA), border = NA)
# Plot the mean density using type = "h" for vertical lines (no offset)
plot(grid, mean_density, type = "h", lwd = 2, col = "gray",
xlab = "y", ylab = "Density", ylim = c(0, y_max),
main = paste("Poisson Mixture Model Density for K =", K))
# Add shaded area for the 95% credible interval
polygon(c(grid, rev(grid)),
c(lower_density, rev(upper_density)),
col = rgb(30/255, 144/255, 255/255, 0.3), border = NA)
# Overlay the observed data as a dotted vertical line density plot, shifted by 'offset'
offset <- 0.1  # Small offset for side-by-side display
obs_density <- table(factor(obs_data, levels = grid)) / length(obs_data)  # Calculate density for observed data
points(grid + offset, obs_density, type = "h", lwd = 2, col = "black", lty = 3)  # Use type "h" with dotted line
# Add a legend to indicate each element
legend("topright", legend = c("Mean Density", "95% CI", "Observed Data"),
col = c("gray", rgb(0, 0, 1, 0.2), "black"), lty = c(1, NA, 3),
lwd = c(2, NA, 2), fill = c(NA, rgb(30/255, 144/255, 255/255, 0.3), NA), border = NA)
# -------------------------------------------------
# Square root Gaussian Mixture Models
# -------------------------------------------------
grid_norm <- seq(min(obs_data) - 1, max(obs_data) + 1, len = 2000)
K = 20
fit_norm <- gmm(y = sqrt(obs_data), grid = grid_norm, K = K, amu = 0, b2mu = 100, asigma2 = 0.1,
bsigma2 = 1, alpha = rep(alpha_p, K), nsim = 5000, nburn = 1000)
density_sqrt_norm <- fit_norm$density
# ESS
ess_values_sqrt_norm <- apply(density_sqrt_norm, 2, coda::effectiveSize)
plot(grid, ess_values_sqrt_norm, type = "l", col = "blue", lwd = 2,
xlab = "Grid Points", ylab = "Effective Sample Size (ESS)")
plot(grid_norm, ess_values_sqrt_norm, type = "l", col = "blue", lwd = 2,
xlab = "Grid Points", ylab = "Effective Sample Size (ESS)")
(grid_norm, ess_values_sqrt_norm, type = "l", col = "black", lwd = 2,
plot(grid_norm, ess_values_sqrt_norm, type = "l", col = "black", lwd = 2,
xlab = "Grid Points", ylab = "Effective Sample Size (ESS)")
points(grid_norm, ess_values_sqrt_norm, pch = 16, col = "black")
set.seed(123)
random_index <- sample(1:ncol(fit_norm$density), 1)
plot(fit_norm$density[, random_index], type = "l",
xlab = "Iteration", ylab = "Density")
dens3m <- apply(fit_norm$density, 2, mean)
dens3l <- apply(fit_norm$density, 2, quantile, prob = 0.025)
dens3h <- apply(fit_norm$density, 2, quantile, prob = 0.975)
dfhist <- data.frame(y = sqrt(obs_data))
dfdens3 <- data.frame(dm = dens3m, dl = dens3l, dh = dens3h,
seqgrid = grid)
ggplot(dfdens3, aes(x = seqgrid, y = dm)) + geom_line(size = 1, colour = "blue") +
geom_ribbon(data = dfdens3, aes(x = seqgrid, ymin = dl, ymax = dh),
alpha = 0.3, fill = "dodgerblue1") + xlab("y") + ylab("Density") + geom_histogram(data = dfhist, aes(x = y,
y = after_stat(density)), alpha = 0.2, bins = 40, inherit.aes = FALSE,
fill = "gray", colour = "black") + theme_bw(base_size = 15) + theme(plot.title = element_text(hjust = 0.5, face="bold"),panel.grid.major = element_blank(),
panel.grid.minor = element_blank(), text = element_text(size = 15))
dfdens3 <- data.frame(dm = dens3m, dl = dens3l, dh = dens3h,
seqgrid = grid_norm)
ggplot(dfdens3, aes(x = seqgrid, y = dm)) + geom_line(size = 1, colour = "blue") +
geom_ribbon(data = dfdens3, aes(x = seqgrid, ymin = dl, ymax = dh),
alpha = 0.3, fill = "dodgerblue1") + xlab("y") + ylab("Density") + geom_histogram(data = dfhist, aes(x = y,
y = after_stat(density)), alpha = 0.2, bins = 40, inherit.aes = FALSE,
fill = "gray", colour = "black") + theme_bw(base_size = 15) + theme(plot.title = element_text(hjust = 0.5, face="bold"),panel.grid.major = element_blank(),
panel.grid.minor = element_blank(), text = element_text(size = 15))
source("code/Bayes_mix_poisson.R")
set.seed(123)
counts_under <- rbinom(500, 10, 0.8)
mean(counts_under) # 8.054
var(counts_under) # 1.1566216
K = 20
# Change to desired alpha parameter
alpha_p = 1
grid <- seq(min(obs_data) - 1, max(obs_data) + 1, by = 1)
obs_data <- counts_under
# -------------------------------------------------
# Poisson Mixture Models
# -------------------------------------------------
# Change to desired K components
K = 20
# Change to desired alpha parameter
alpha_p = 1
grid <- seq(min(obs_data) - 1, max(obs_data) + 1, by = 1)
res_pois <- pmm(y = obs_data, grid = grid, K = K, alpha = 1, beta = 1, alpha_dir = rep(alpha_p,K))
source("code/Bayes_mix_poisson.R")
require(coda)
require(rjags)
grid <- seq(min(obs_data) - 1, max(obs_data) + 1, by = 1)
res_pois <- pmm(y = obs_data, grid = grid, K = K, alpha = 1, beta = 1, alpha_dir = rep(alpha_p,K))
density_pmm <- res_pois$density
# ESS
ess_values <- apply(density_pmm, 2, coda::effectiveSize)
plot(grid, ess_values, type = "l", col = "black", lwd = 2,
xlab = "Grid Points", ylab = "Effective Sample Size (ESS)")
points(grid, ess_values, pch = 16, col = "black")
# Traceplot
set.seed(123)
random_index <- sample(1:ncol(density_pmm), 1)
# Plot the trace of the density at this selected grid point
plot(density_pmm[, random_index], type = "l",
xlab = "Iteration", ylab = "Density")
# Estimated density
mean_density <- apply(density_pmm, 2, mean)
lower_density <- apply(density_pmm, 2, quantile, prob = 0.025)
upper_density <- apply(density_pmm, 2, quantile, prob = 0.975)
density_df <- data.frame(
grid = grid,
mean_density = mean_density,
lower_density = lower_density,
upper_density = upper_density
)
# plot
y_max <- max(c(mean_density, obs_density)) * 1
plot(grid, mean_density, type = "h", lwd = 2, col = "gray",
xlab = "y", ylab = "Density", ylim = c(0, y_max),
main = paste("Poisson Mixture Model Density for K =", K))
# Add shaded area for the 95% credible interval
polygon(c(grid, rev(grid)),
c(lower_density, rev(upper_density)),
col = rgb(30/255, 144/255, 255/255, 0.3), border = NA)
offset <- 0.1
obs_density <- table(factor(obs_data, levels = grid)) / length(obs_data)
y_max <- max(c(mean_density, obs_density)) * 1
plot(grid, mean_density, type = "h", lwd = 2, col = "gray",
xlab = "y", ylab = "Density", ylim = c(0, y_max),
main = paste("Poisson Mixture Model Density for K =", K))
# Add shaded area for the 95% credible interval
polygon(c(grid, rev(grid)),
c(lower_density, rev(upper_density)),
col = rgb(30/255, 144/255, 255/255, 0.3), border = NA)
offset <- 0.1
obs_density <- table(factor(obs_data, levels = grid)) / length(obs_data)
points(grid + offset, obs_density, type = "h", lwd = 2, col = "black", lty = 3)
legend("topright", legend = c("Mean Density", "95% CI", "Observed Data"),
col = c("gray", rgb(0, 0, 1, 0.2), "black"), lty = c(1, NA, 3),
lwd = c(2, NA, 2), fill = c(NA, rgb(30/255, 144/255, 255/255, 0.3), NA), border = NA)
source("code/Bayes_mix_student_t.R")
source("code/Bayes_mix_student_t.R")
set.seed(123)
# Parameters for the main normal distribution
N <- 100
mu <- 3
sigma <- 1.15
# Generate main normal data
y <- rnorm(N, mu, sigma)
# Proportion of outliers and amount of shift for outliers
prop_outliers <- 0.1  # Higher proportion of outliers for heavier tails
shift <- 20           # Larger shift for more extreme outliers
t_df <- 3             # Degrees of freedom for t-distribution (heavier tails)
# Determine number of outliers
n_outliers <- round(N * prop_outliers)
# Select indices for outliers
ind_outliers <- sample(1:N, size = n_outliers)
# Initialize outlier-adjusted data
y_outliers <- numeric(N)
# Assign non-outlier data
y_outliers[1:(N - length(ind_outliers))] <- y[-ind_outliers]
# Assign outliers using a t-distribution for heavy tails and add shift
y_outliers[(N - length(ind_outliers) + 1):N] <- rt(n_outliers, df = t_df) * sigma + mu + shift
# Final data with outliers and heavier tails
y_data <- y_outliers
K =20
alpha = 1
tmix_sample <- tmix_nimble(y_data, grid = grid, K = K, amu = 0, b2mu = 0.01,
asigma2 = 1, bsigma2 = 1, rate_nu = 0.1, alpha_dirichlet = rep(alpha,K),
nsim = 5000, nburn = 1000)
grid <- seq(min(y_data) - 1, max(y_data) + 1, length.out = 200)
tmix_sample <- tmix_nimble(y_data, grid = grid, K = K, amu = 0, b2mu = 0.01,
asigma2 = 1, bsigma2 = 1, rate_nu = 0.1, alpha_dirichlet = rep(alpha,K),
nsim = 5000, nburn = 1000)
samples_t_mixture <- tmix_sample$samples
sample_t_dens <- tmix_sample$density
set.seed(123)
random_index <- sample(1:ncol(sample_t_dens), 1)
random_index
plot(sample_t_dens[, random_index], type = "l",
xlab = "Iteration", ylab = "Density")
plot(grid, ess_values, type = "l", col = "black", lwd = 2,
xlab = "Grid Points", ylab = "Effective Sample Size (ESS)")
points(grid, ess_values, pch = 16, col = "black")
# ESS
ess_values <- apply(sample_t_dens, 2, coda::effectiveSize)
plot(grid, ess_values, type = "l", col = "black", lwd = 2,
xlab = "Grid Points", ylab = "Effective Sample Size (ESS)")
points(grid, ess_values, pch = 16, col = "black")
density <- sample_t_dens
mean_density <- apply(density, 2, mean)
lower_density <- apply(density, 2, quantile, prob = 0.025)
upper_density <- apply(density, 2, quantile, prob = 0.975)
# Create a data frame for the densities
density_df <- data.frame(grid = grid,
mean_density = mean_density,
lower_density = lower_density,
upper_density = upper_density)
df_hist <- data.frame(y = y_data)
ggplot() +
geom_histogram(data = df_hist, aes(x = y, y = after_stat(density)), bins = 40, alpha = 0.3, fill = "gray", color = "black") +
geom_line(data = density_df, aes(x = grid, y = mean_density), color = "blue", size = 1) +
geom_ribbon(data = density_df, aes(x = grid, ymin = lower_density, ymax = upper_density), alpha = 0.3, fill = "dodgerblue") +
geom_rug(data = df_hist, aes(x = y), sides = "b", color = "darkblue", alpha = 0.7) +
xlab("y") +
ylab("Density") +
theme_bw(base_size = 15) + theme(plot.title = element_text(hjust = 0.5, face="bold"),panel.grid.major = element_blank(),
panel.grid.minor = element_blank(), text = element_text(size = 15))
require(ggplot2)
ggplot() +
geom_histogram(data = df_hist, aes(x = y, y = after_stat(density)), bins = 40, alpha = 0.3, fill = "gray", color = "black") +
geom_line(data = density_df, aes(x = grid, y = mean_density), color = "blue", size = 1) +
geom_ribbon(data = density_df, aes(x = grid, ymin = lower_density, ymax = upper_density), alpha = 0.3, fill = "dodgerblue") +
geom_rug(data = df_hist, aes(x = y), sides = "b", color = "darkblue", alpha = 0.7) +
xlab("y") +
ylab("Density") +
theme_bw(base_size = 15) + theme(plot.title = element_text(hjust = 0.5, face="bold"),panel.grid.major = element_blank(),
panel.grid.minor = element_blank(), text = element_text(size = 15))
fit_norm <- gmm(y = y_data, grid = grid, K = 20, amu = 0, b2mu = 0.01, asigma2 = 0.1,
bsigma2 = 1, alpha = rep(alpha, 20), nsim = 5000, nburn = 1000)
source("code/Bayes_mix_normal.R")
fit_norm <- gmm(y = y_data, grid = grid, K = 20, amu = 0, b2mu = 0.01, asigma2 = 0.1,
bsigma2 = 1, alpha = rep(alpha, 20), nsim = 5000, nburn = 1000)
# traceplot
plot(fit_norm$density[, random_index], type = "l",
xlab = "Iteration", ylab = "Density")
# ess
ess_values_gmm <- apply(fit_norm$density, 2, coda::effectiveSize)
plot(grid, ess_values_gmm, type = "l", col = "black", lwd = 2,
xlab = "Grid Points", ylab = "Effective Sample Size (ESS)")
points(grid, ess_values_gmm, pch = 16, col = "black")
dens3m <- apply(fit_norm$density, 2, mean)
dens3l <- apply(fit_norm$density, 2, quantile, prob = 0.025)
dens3h <- apply(fit_norm$density, 2, quantile, prob = 0.975)
df_hist <- data.frame(y = y_data)
dfdens3 <- data.frame(dm = dens3m, dl = dens3l, dh = dens3h,
seqgrid = grid)
ggplot() +
geom_histogram(data = df_hist, aes(x = y, y = after_stat(density)), bins = 40, alpha = 0.3, fill = "gray", color = "black") +
geom_line(data = density_df, aes(x = grid, y = mean_density), color = "blue", size = 1) +
geom_ribbon(data = density_df, aes(x = grid, ymin = lower_density, ymax = upper_density), alpha = 0.3, fill = "dodgerblue") +
geom_rug(data = df_hist, aes(x = y), sides = "b", color = "darkblue", alpha = 0.7) +
xlab("y") +
ylab("Density") +
ggtitle("GMM on Data (10% Outliers) K = 20") +
theme_bw(base_size = 15) + theme(plot.title = element_text(hjust = 0.5, face="bold"),panel.grid.major = element_blank(),
panel.grid.minor = element_blank(), text = element_text(size = 15))
ggplot() +
geom_histogram(data = df_hist, aes(x = y, y = after_stat(density)), bins = 40, alpha = 0.3, fill = "gray", color = "black") +
geom_line(data = density_df, aes(x = grid, y = mean_density), color = "blue", size = 1) +
geom_ribbon(data = density_df, aes(x = grid, ymin = lower_density, ymax = upper_density), alpha = 0.3, fill = "dodgerblue") +
geom_rug(data = df_hist, aes(x = y), sides = "b", color = "darkblue", alpha = 0.7) +
xlab("y") +
ylab("Density")+
theme_bw(base_size = 15) + theme(plot.title = element_text(hjust = 0.5, face="bold"),panel.grid.major = element_blank(),
panel.grid.minor = element_blank(), text = element_text(size = 15))
source("code/Bayes_mix_normal.R")
